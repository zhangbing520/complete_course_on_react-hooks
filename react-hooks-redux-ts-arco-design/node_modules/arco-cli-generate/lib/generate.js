"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const arco_cli_config_1 = require("arco-cli-config");
const arco_cli_auth_1 = require("arco-cli-auth");
const arco_cli_dev_utils_1 = require("arco-cli-dev-utils");
const locale_1 = __importDefault(require("./locale"));
const { isMetaExist, getMetaPath } = arco_cli_dev_utils_1.materialMeta;
const BASE_META = {
    name: '',
    title: '',
    description: '',
    type: '',
    category: '',
    group: 0,
    homepage: '',
    repository: '',
    author: '',
    screenshot: '',
    package: {
        name: '',
        version: 'latest',
        type: 'npm',
        registry: '',
        peerDependencies: [],
    },
};
/**
 * Generate material meta info in project
 */
exports.default = ({ metaFileName = 'arcoMeta', configFileName, paths, meta: initialMeta, silent, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, arco_cli_auth_1.checkLogin)();
    const { userInfo, group: globalLinkedGroupId } = (0, arco_cli_dev_utils_1.getGlobalInfo)();
    const arcoCliConfig = (0, arco_cli_config_1.getConfig)(configFileName);
    const meta = Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_META), (globalLinkedGroupId ? { group: globalLinkedGroupId } : {})), arcoCliConfig.initialMeta), initialMeta);
    const messageQueue = new arco_cli_dev_utils_1.MessageQueue({
        description: locale_1.default.LABEL_GENERATE_RESULT,
    });
    /**
     * @param root CWD of process
     * @returns {boolean} Whether there is a meta file in the directory
     */
    const generateMeta = (root) => {
        process.chdir(root);
        // Check package.json
        let packageJson;
        try {
            packageJson = require(path_1.default.resolve(root, 'package.json')) || {};
        }
        catch (e) {
            messageQueue.push('error', [root, locale_1.default.ERROR_NO_VALID_PACKAGE_JSON]);
            return false;
        }
        const packageName = packageJson.name;
        // Check if the meta file already exists
        if (isMetaExist()) {
            messageQueue.push('warn', [packageName, locale_1.default.WARN_META_FILE_EXIST]);
            return true;
        }
        // Check 'arcoMeta' in package.json
        if (!packageJson[metaFileName]) {
            messageQueue.push('error', [packageName, locale_1.default.ERROR_NO_ARCO_META_IN_PACKAGE_JSON]);
            return false;
        }
        const metaPath = getMetaPath({ metaFileName });
        const metaInPackageJson = packageJson[metaFileName];
        fs_extra_1.default.writeJsonSync(metaPath, Object.assign(Object.assign({}, meta), { name: packageName, description: packageJson.description, author: userInfo === null || userInfo === void 0 ? void 0 : userInfo.name, title: metaInPackageJson.title, type: metaInPackageJson.type, category: metaInPackageJson.category, package: Object.assign(Object.assign({}, meta.package), { name: packageName, peerDependencies: Object.keys(packageJson.peerDependencies || {}) }) }), { spaces: 2 });
        messageQueue.push('success', [packageName, locale_1.default.TIP_GENERATE_SUCCESS]);
        return true;
    };
    // Execute material generation in all specified directories
    const originalPath = process.cwd();
    paths = paths ? (Array.isArray(paths) ? paths : [paths]) : arcoCliConfig.packages;
    const results = paths.map(generateMeta);
    !silent && messageQueue.flush();
    process.chdir(originalPath);
    return results.every((result) => result !== false);
});
