"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const ora_1 = __importDefault(require("ora"));
const arco_cli_dev_utils_1 = require("arco-cli-dev-utils");
const locale_1 = __importDefault(require("./locale"));
const TEMPLATE_DIR = 'template';
const TEMPLATE_DIR_FOR_MONOREPO = 'template-for-monorepo';
const CUSTOM_INIT_DIR = '.arco-cli';
// Path of directory to download template from npm, will be removed after project created
const PATH_TEMPLATE_DOWNLOAD = path_1.default.resolve(arco_cli_dev_utils_1.CONSTANT.PATH_HOME_DIR, '.arco_template_cache', `${+Date.now()}`);
function addGitIgnore() {
    const sourceFilename = 'gitignore';
    const targetFilename = '.gitignore';
    if (fs_extra_1.default.existsSync(sourceFilename)) {
        if (fs_extra_1.default.existsSync(targetFilename)) {
            const data = fs_extra_1.default.readFileSync(sourceFilename);
            fs_extra_1.default.appendFileSync(targetFilename, data);
            fs_extra_1.default.unlinkSync(sourceFilename);
        }
        else {
            try {
                fs_extra_1.default.moveSync(sourceFilename, targetFilename);
            }
            catch (e) { }
        }
    }
}
function tryGitCommit(commitMessage) {
    return __awaiter(this, void 0, void 0, function* () {
        const { code: codeAdd, stderr: errAdd } = yield (0, arco_cli_dev_utils_1.execQuick)('git add -A');
        const { code: codeCommit, stderr: errCommit } = yield (0, arco_cli_dev_utils_1.execQuick)(`git commit -m "${commitMessage}" --no-verify`);
        if (codeAdd !== 0 || codeCommit !== 0) {
            arco_cli_dev_utils_1.print.warn('Git commit not created', errAdd || errCommit);
            arco_cli_dev_utils_1.print.warn('Removing .git directory...');
            try {
                fs_extra_1.default.removeSync('./.git');
            }
            catch (_) { }
        }
    });
}
function getPackageInfo(installPackage) {
    // match package with version
    if (installPackage.match(/.+@/)) {
        return {
            name: installPackage.charAt(0) + installPackage.substr(1).split('@')[0],
            version: installPackage.split('@')[1],
        };
    }
    // match local file path
    if (installPackage.match(/^file:/)) {
        const installPackagePath = installPackage.match(/^file:(.*)?$/)[1];
        const { name, version } = require(path_1.default.join(installPackagePath, 'package.json'));
        return { name, version };
    }
    return { name: installPackage };
}
function handleDependencies(dependencies, allowYarn = false) {
    return __awaiter(this, void 0, void 0, function* () {
        let command = 'npm';
        let args = ['install'].concat(dependencies || []);
        if (allowYarn) {
            try {
                const { stdout } = yield (0, arco_cli_dev_utils_1.execQuick)('yarn -v');
                if (stdout.match(/^\d+\.\d+/)) {
                    command = 'yarn';
                    args = dependencies ? ['add'].concat(dependencies) : [];
                }
            }
            catch (e) { }
        }
        const commandExec = `${command} ${args.join(' ')}`;
        const { code, stderr } = yield (0, arco_cli_dev_utils_1.execQuick)(commandExec);
        if (code !== 0) {
            throw new Error(`Command 「${commandExec}」 executed failed:\n${stderr}`);
        }
    });
}
function exitProcess(err) {
    console.error(err);
    fs_extra_1.default.removeSync(PATH_TEMPLATE_DOWNLOAD);
    process.exit(1);
}
function copyTemplateContent({ root, spinner, template, isForMonorepo, customInitFunctionParams, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const prevCwd = process.cwd();
        fs_extra_1.default.ensureDirSync(PATH_TEMPLATE_DOWNLOAD);
        process.chdir(PATH_TEMPLATE_DOWNLOAD);
        // Download template
        try {
            spinner.start(locale_1.default.TIP_TEMPLATE_DOWNLOAD_ING);
            // Init a empty package.json
            fs_extra_1.default.writeJsonSync('./package.json', {});
            yield handleDependencies(template);
            spinner.succeed(locale_1.default.TIP_TEMPLATE_DOWNLOAD_DONE);
        }
        catch (err) {
            spinner.fail(locale_1.default.TIP_TEMPLATE_DOWNLOAD_FAILED);
            exitProcess(err);
        }
        const pathTemplatePackage = path_1.default.resolve(`node_modules/${getPackageInfo(template).name}`);
        process.chdir(pathTemplatePackage);
        // Copy content of template
        try {
            spinner.start(locale_1.default.TIP_TEMPLATE_COPY_ING);
            const pathCustomProjectInitFunc = path_1.default.resolve(`${CUSTOM_INIT_DIR}/init.js`);
            if (fs_extra_1.default.existsSync(TEMPLATE_DIR) || fs_extra_1.default.existsSync(TEMPLATE_DIR_FOR_MONOREPO)) {
                yield fs_extra_1.default.copy(isForMonorepo && TEMPLATE_DIR_FOR_MONOREPO ? TEMPLATE_DIR_FOR_MONOREPO : TEMPLATE_DIR, root, {
                    overwrite: true,
                });
            }
            else if (fs_extra_1.default.existsSync(pathCustomProjectInitFunc)) {
                const init = require(pathCustomProjectInitFunc);
                yield init(Object.assign(Object.assign({}, customInitFunctionParams), { projectPath: root }));
            }
            spinner.succeed(locale_1.default.TIP_TEMPLATE_COPY_DONE);
        }
        catch (err) {
            spinner.fail(locale_1.default.TIP_TEMPLATE_COPY_FAILED);
            exitProcess(err);
        }
        let afterInit;
        try {
            afterInit = require(path_1.default.resolve(`${pathTemplatePackage}/hook/after-init.js`));
        }
        catch (e) { }
        try {
            afterInit = require(path_1.default.resolve(`${pathTemplatePackage}/${CUSTOM_INIT_DIR}/after-init.js`));
        }
        catch (e) { }
        process.chdir(prevCwd);
        return afterInit;
    });
}
function default_1({ root, template, projectName = '', packageJson = {}, isForMonorepo = false, beforeGitCommit, customInitFunctionParams, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const spinner = (0, ora_1.default)();
        const originalDirectory = process.cwd();
        if (template.match(/^file:/)) {
            template = `file:${path_1.default.resolve(originalDirectory, template.match(/^file:(.*)?$/)[1])}`;
        }
        (0, arco_cli_dev_utils_1.print)(`\n${locale_1.default.TIP_PROJECT_INIT_ING} ${chalk_1.default.green(root)}`);
        fs_extra_1.default.emptyDirSync(root);
        process.chdir(root);
        const afterInit = yield copyTemplateContent({
            root,
            spinner,
            template,
            isForMonorepo,
            customInitFunctionParams,
        });
        // Preprocess template content, replace constants, process package names, etc.
        try {
            spinner.start(locale_1.default.TIP_TEMPLATE_ADAPT_ING);
            yield arco_cli_dev_utils_1.materialTemplate.transformToProject({
                root,
                packageJson,
            });
            spinner.succeed(locale_1.default.TIP_TEMPLATE_ADAPT_DONE);
        }
        catch (err) {
            spinner.fail(locale_1.default.TIP_TEMPLATE_ADAPT_FAILED);
            exitProcess(err);
        }
        // Init Git
        addGitIgnore();
        if (!(yield (0, arco_cli_dev_utils_1.isInGitRepository)())) {
            const { stderr, code } = yield (0, arco_cli_dev_utils_1.execQuick)('git init');
            code !== 0 && arco_cli_dev_utils_1.print.warn(locale_1.default.ERROR_GIT_INIT_FAILED, stderr);
        }
        // Install dependencies
        try {
            spinner.start(locale_1.default.TIP_DEPENDENCIES_INSTALL_ING);
            yield handleDependencies(null, true);
            spinner.succeed(locale_1.default.TIP_DEPENDENCIES_INSTALL_DONE);
        }
        catch (err) {
            spinner.fail(locale_1.default.TIP_DEPENDENCIES_INSTALL_FAILED);
            arco_cli_dev_utils_1.print.error(err);
        }
        typeof beforeGitCommit === 'function' && beforeGitCommit();
        // Execute after-init.js defined in template
        try {
            if (afterInit) {
                yield afterInit({
                    root,
                    projectName,
                    isForMonorepo,
                });
            }
            else {
                // Try to build project
                spinner.start(locale_1.default.TIP_PROJECT_BUILD_ING);
                const { code, stderr } = yield (0, arco_cli_dev_utils_1.execQuick)('npm run build');
                if (code === 0) {
                    spinner.succeed(locale_1.default.TIP_PROJECT_BUILD_DONE);
                }
                else {
                    spinner.warn(locale_1.default.TIP_PROJECT_BUILD_FAILED);
                    arco_cli_dev_utils_1.print.warn(`Command executed failed: npm run build\n${stderr}`);
                }
                // Print help info
                arco_cli_dev_utils_1.print.divider();
                arco_cli_dev_utils_1.print.success(` ${locale_1.default.TIP_PROJECT_INIT_DONE}`);
                if (isForMonorepo) {
                    arco_cli_dev_utils_1.print.success(` ${locale_1.default.TIP_HELP_INFO_LERNA}`);
                    arco_cli_dev_utils_1.print.success('   $ yarn dev');
                }
                else {
                    arco_cli_dev_utils_1.print.success(` ${locale_1.default.TIP_HELP_INFO}`);
                    arco_cli_dev_utils_1.print.success(`   $ cd ${projectName}`);
                    arco_cli_dev_utils_1.print.success('   $ npm run dev');
                }
                arco_cli_dev_utils_1.print.divider();
            }
        }
        catch (error) {
            arco_cli_dev_utils_1.print.error(['arco-init'], locale_1.default.ERROR_PROJECT_INIT_FAILED);
            arco_cli_dev_utils_1.print.error(error);
        }
        // First Git commit
        yield tryGitCommit(`arco-cli: ${isForMonorepo ? 'add package' : 'initialize'} ${packageJson.name || 'project'}`);
        // Clear template download directory
        fs_extra_1.default.removeSync(PATH_TEMPLATE_DOWNLOAD);
    });
}
exports.default = default_1;
