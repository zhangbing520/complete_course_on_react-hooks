"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const nanoid_1 = require("nanoid");
const arco_cli_generate_1 = __importDefault(require("arco-cli-generate"));
const arco_cli_config_1 = require("arco-cli-config");
const arco_cli_auth_1 = require("arco-cli-auth");
const arco_cli_dev_utils_1 = require("arco-cli-dev-utils");
const screenshot_1 = __importDefault(require("./screenshot"));
const locale_1 = __importDefault(require("./locale"));
const { getMetaPath } = arco_cli_dev_utils_1.materialMeta;
const doScreenshot = (path, packageInfo) => __awaiter(void 0, void 0, void 0, function* () {
    if (!path) {
        path = `${(0, nanoid_1.nanoid)()}.png`;
        const { name, version } = packageInfo;
        const screenShotUrl = `https://arco.design/material/preview?name=${name}&version=${version}`;
        const screenshotSelector = '.arco-material-live-preview > *';
        yield (0, screenshot_1.default)({ path, url: screenShotUrl, selector: screenshotSelector });
    }
    try {
        // TODO need to rewrite
        const { url } = yield arco_cli_auth_1.request.post('tos', { buffer: fs_extra_1.default.readFileSync(path), path });
        return url.startsWith('http') ? url : `https:${url}`;
    }
    finally {
        fs_extra_1.default.unlink(path, () => { });
    }
});
const updateLocalMeta = (localMeta, originMeta) => {
    Object.keys(localMeta).forEach((key) => {
        localMeta[key] = originMeta[key];
    });
    if (originMeta.metaUpdateTime) {
        localMeta.metaUpdateTime = originMeta.metaUpdateTime;
    }
    // Useless field, delete it
    delete localMeta.updatedAt;
    return localMeta;
};
/**
 * Synchronize material meta
 */
function default_1({ metaFileName = 'arcoMeta', configFileName, screenshot, paths, fetch = false, } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, arco_cli_auth_1.checkLogin)();
        const messageQueue = new arco_cli_dev_utils_1.MessageQueue({
            description: locale_1.default.TIP_CMD_EXEC_RESULT,
        });
        const syncMeta = (root) => __awaiter(this, void 0, void 0, function* () {
            process.chdir(root);
            // Ensure that the material has been released to NPM
            let packageInfo = null;
            try {
                packageInfo = yield (0, arco_cli_dev_utils_1.getNpmPackageInfo)();
            }
            catch (e) {
                const errMsg = e.toString();
                const errorPrefix = /code E404|404 Not Found/gi.test(errMsg)
                    ? locale_1.default.ERROR_NEED_PUBLISH_TO_NPM
                    : locale_1.default.ERROR_GET_PACKAGE_INFO_FAILED;
                messageQueue.push('error', [root, `${errorPrefix}\n${errMsg}`]);
                return;
            }
            // Ensure that arcoMeta.json has been generated
            const { name: packageName, peerDependencies = {} } = packageInfo;
            const metaPath = getMetaPath({ metaFileName });
            if (!fs_extra_1.default.existsSync(metaPath)) {
                arco_cli_dev_utils_1.print.info(packageName, locale_1.default.TIP_META_GENERATE_ING);
                const result = yield (0, arco_cli_generate_1.default)({ paths: [root], silent: true });
                if (result) {
                    arco_cli_dev_utils_1.print.info(packageName, locale_1.default.TIP_META_GENERATE_DONE);
                }
                else {
                    messageQueue.push('error', [packageName, locale_1.default.ERROR_META_GENERATE_FAILED]);
                    return;
                }
            }
            const localMeta = require(metaPath);
            const { result: [originMeta], } = yield arco_cli_auth_1.request.post('material', { name: packageName });
            // Update local meta from origin
            if (fetch) {
                if (originMeta) {
                    fs_extra_1.default.writeJsonSync(metaPath, updateLocalMeta(localMeta, originMeta), { spaces: 2 });
                    messageQueue.push('success', [packageName, locale_1.default.TIP_META_FETCH_SUCCESS]);
                }
                else {
                    messageQueue.push('error', [packageName, locale_1.default.ERROR_META_FETCH_FAILED]);
                }
            }
            else {
                arco_cli_dev_utils_1.print.info(packageName, locale_1.default.TIP_META_SYNC_ING);
                // Check whether the local material meta is behind the remote
                if (originMeta &&
                    originMeta.name === packageName &&
                    +new Date(localMeta.metaUpdateTime) < +new Date(originMeta.metaUpdateTime)) {
                    messageQueue.push('error', [packageName, locale_1.default.ERROR_META_SHOULD_FETCH_FIRST]);
                    return;
                }
                const metaUpdateParams = Object.assign(Object.assign({}, localMeta), { group: +localMeta.group, package: Object.assign(Object.assign({}, localMeta.package), { peerDependencies: Object.keys(peerDependencies) }) });
                // Auto generate screenshot
                if (screenshot) {
                    try {
                        const imagePath = typeof screenshot === 'string' ? screenshot : null;
                        metaUpdateParams.screenshot = yield doScreenshot(imagePath, packageInfo);
                    }
                    catch (err) {
                        arco_cli_dev_utils_1.print.error(packageName, `${locale_1.default.ERROR_AUTO_SCREENSHOT_FAILED} ${err.toString()}`);
                    }
                }
                try {
                    const { ok, msg, result } = yield arco_cli_auth_1.request.post(`material/${originMeta ? 'update' : 'create'}`, {
                        meta: metaUpdateParams,
                    });
                    if (ok) {
                        const hostArco = (0, arco_cli_dev_utils_1.getGlobalInfo)().host.arco;
                        fs_extra_1.default.writeJsonSync(metaPath, updateLocalMeta(localMeta, result), { spaces: 2 });
                        messageQueue.push('success', [
                            packageName,
                            `${locale_1.default.TIP_META_SYNC_DONE} ${hostArco}/material/detail?name=${packageName}`,
                        ]);
                    }
                    else {
                        messageQueue.push('error', [packageName, msg || locale_1.default.ERROR_META_SYNC_FAILED]);
                    }
                }
                catch (err) {
                    messageQueue.push('error', [packageName, err]);
                }
            }
        });
        // Try to sync meta in all specified paths
        const originalPath = process.cwd();
        paths = paths ? (Array.isArray(paths) ? paths : [paths]) : (0, arco_cli_config_1.getConfig)(configFileName).packages;
        yield Promise.all(paths.map((path) => syncMeta(path)));
        messageQueue.flush();
        process.chdir(originalPath);
    });
}
exports.default = default_1;
