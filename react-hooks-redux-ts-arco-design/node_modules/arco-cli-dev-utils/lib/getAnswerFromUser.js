"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver_1 = __importDefault(require("semver"));
const inquirer_1 = __importDefault(require("inquirer"));
const locale_1 = __importDefault(require("./locale"));
const getLocale_1 = __importDefault(require("./getLocale"));
const baseConfig_1 = require("./baseConfig");
const LOCALE = (0, getLocale_1.default)();
/**
 * Get valid item by filter
 */
function isValid(filter, filterParams) {
    if (!filter) {
        return true;
    }
    const cliVersion = global.ARCO_CLI_VERSION;
    for (const key in filter) {
        if (key === 'version') {
            if (cliVersion && semver_1.default.lt(cliVersion, filter[key])) {
                return false;
            }
            continue;
        }
        if (typeof filter[key] === 'boolean') {
            if (filter[key] !== filterParams[key]) {
                return false;
            }
            continue;
        }
        if (typeof filter[key] === 'object') {
            const { type, value } = filter[key];
            const index = Array.isArray(value) ? value.indexOf(filterParams[key]) : null;
            if (index !== null &&
                ((type === 'include' && index === -1) || (type === 'exclude' && index !== -1))) {
                return false;
            }
        }
    }
    return true;
}
/**
 * Ask user a question by inquirer
 */
function askQuestion({ type, message, validate, choices, default: _default, allowCreate }, currentInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        // Get message string by locale
        const transformMessage = (msg) => (typeof msg === 'object' ? msg[LOCALE] : msg);
        const choiceValueOfCustomInput = '__custom_input';
        const paramsForInquirer = {
            name: 'result',
            type,
            default: _default,
            message: transformMessage(message),
            loop: false,
            pageSize: 10,
        };
        if (type === 'input') {
            paramsForInquirer.validate = (input) => {
                const { rule, message } = validate || {};
                if (rule === 'required') {
                    return input.trim() ? true : transformMessage(message);
                }
                return true;
            };
        }
        if (type === 'list' || type === 'checkbox') {
            const _choices = [];
            // Filter valid choices
            if (Array.isArray(choices)) {
                for (const { _filter, _labelAsValue, label, value } of choices) {
                    if (isValid(_filter, currentInfo)) {
                        const name = transformMessage(label);
                        _choices.push({
                            name,
                            value: _labelAsValue ? name : value,
                        });
                    }
                }
            }
            if (allowCreate) {
                _choices.push({
                    name: locale_1.default.LABEL_CHOICE_CUSTOM_INPUT,
                    value: choiceValueOfCustomInput,
                });
            }
            // Ask the user only if there is more than one choice
            if (_choices.length === 0) {
                return null;
            }
            if (_choices.length === 1 && _choices[0].value !== choiceValueOfCustomInput) {
                return _choices[0].value;
            }
            paramsForInquirer.choices = _choices;
        }
        const { result } = yield inquirer_1.default.prompt(paramsForInquirer);
        if ((type === 'list' && result === choiceValueOfCustomInput) ||
            (type === 'checkbox' && result.indexOf(choiceValueOfCustomInput) > -1)) {
            const { input } = yield inquirer_1.default.prompt({
                type: 'input',
                name: 'input',
                message: locale_1.default.TIP_CUSTOM_INPUT,
            });
            const customInputValue = input
                .split(/[,ï¼Œ]/)
                .map((item) => item.trim())
                .filter((item) => item);
            return type === 'checkbox'
                ? result.filter((item) => item !== choiceValueOfCustomInput).concat(customInputValue)
                : customInputValue[0];
        }
        return result;
    });
}
function walkQuestionNodes({ questions, callback, filterInherit = {}, record = {}, }) {
    questions.forEach((node) => {
        const { _question, _filter, _key } = node;
        const filter = Object.assign(Object.assign({}, filterInherit), _filter);
        if (Array.isArray(_question)) {
            record[_key] = walkQuestionNodes({
                callback,
                questions: _question,
                filterInherit: filter,
            });
        }
        else {
            callback({ question: _question, key: _key, filter, record });
        }
    });
    return record;
}
function getAnswerFromUser({ command, baseInfo, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { question: { [command]: questions }, } = yield (0, baseConfig_1.getBaseConfig)();
        const info = Object.assign({}, baseInfo);
        const taskQueue = [];
        walkQuestionNodes({
            questions,
            record: info,
            callback: ({ question, key, filter, record }) => {
                // If there is a answer in baseInfo, skip asking
                if (record[key] === undefined) {
                    taskQueue.push(() => __awaiter(this, void 0, void 0, function* () {
                        if (isValid(filter, info)) {
                            record[key] = yield askQuestion(question, info);
                        }
                    }));
                }
            },
        });
        const clearTasks = () => __awaiter(this, void 0, void 0, function* () {
            const task = taskQueue.shift();
            if (task) {
                yield task();
                yield clearTasks();
            }
        });
        yield clearTasks();
        return info;
    });
}
exports.default = getAnswerFromUser;
