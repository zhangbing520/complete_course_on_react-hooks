"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executePageWriting = exports.arcoPageInsert = exports.arcoBlockInsert = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const arco_cli_dev_utils_1 = require("arco-cli-dev-utils");
const downloader_1 = require("./downloader");
const util_1 = require("./util");
const babel_1 = require("./babel");
const locale_1 = __importDefault(require("./locale"));
const PATH_TARGET_IN_PROJECT = 'src/pages';
const PATH_SOURCE_IN_MATERIAL = 'src/page';
function handleFsCopy(source, target) {
    return __awaiter(this, void 0, void 0, function* () {
        const cpCommand = `cp -rf '${source}/.' '${target}'`;
        const isTargetPathExists = fs_1.default.existsSync(target);
        if (!isTargetPathExists) {
            yield (0, mkdirp_1.default)(target);
        }
        yield (0, arco_cli_dev_utils_1.execQuick)(cpCommand);
    });
}
function handleArcoProFsWrite(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { pageName, codeDownloadPath, packageName, cwd } = config;
        const pagePath = path_1.default.join(cwd, PATH_TARGET_IN_PROJECT, pageName);
        yield (0, mkdirp_1.default)(pagePath);
        // Currently we copy files under src.
        const codePath = path_1.default.join(codeDownloadPath, PATH_SOURCE_IN_MATERIAL);
        const isPathExists = fs_1.default.existsSync(codePath);
        if (!isPathExists) {
            throw new Error(`Directory ${PATH_SOURCE_IN_MATERIAL} not found in ${packageName}, cannot insert to project as a page.`);
        }
        const cpCommand = `cp -rf '${codePath}/.' '${pagePath}'`;
        yield (0, arco_cli_dev_utils_1.execQuick)(cpCommand);
        return pagePath;
    });
}
function arcoBlockInsertInner({ packageName, sourcePath, targetPath }, { rootPath }, npmPackageManipulator, logProgress) {
    return __awaiter(this, void 0, void 0, function* () {
        yield npmPackageManipulator.downloadAndUnzipNpmPackage(packageName);
        logProgress(locale_1.default.TIP_COPY_SOURCE_ING);
        const pathCodeDownload = npmPackageManipulator.getPackageDownloadPath(packageName);
        const source = path_1.default.join(pathCodeDownload, 'src', sourcePath);
        const target = path_1.default.join(rootPath, 'src', targetPath);
        if (!fs_1.default.existsSync(source)) {
            throw new Error(`Directory ${sourcePath} not found in ${packageName}`);
        }
        yield handleFsCopy(source, target);
        logProgress(locale_1.default.TIP_COPY_SOURCE_DONE);
        // Installing dependencies.
        const depStr = npmPackageManipulator.getPackageDependenciesPackString(packageName, rootPath);
        if (depStr.trim() !== '') {
            logProgress(`${locale_1.default.TIP_INSTALL_DEP_ING}${depStr}`);
            const exitCode = yield (0, util_1.installDependency)(depStr, rootPath, logProgress);
            if (exitCode !== 0) {
                throw new Error(`Failed to install npm dependency [${depStr}], please check package manager or install them manually.`);
            }
            else {
                logProgress(locale_1.default.TIP_INSTALL_DEP_DONE);
            }
        }
    });
}
/**
 * Insert block
 */
function arcoBlockInsert(config, ctxConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultLogger = new util_1.DefaultLogger(locale_1.default.TIP_INSERT_BLOCK_ING);
        const logProgress = ctxConfig.silent ? () => { } : (_msg) => defaultLogger.log(_msg);
        const npmPackageManipulator = new downloader_1.NpmPackageManipulator({
            root: ctxConfig.rootPath,
            log: logProgress,
        });
        try {
            yield arcoBlockInsertInner(config, ctxConfig, npmPackageManipulator, logProgress);
        }
        catch (e) {
            defaultLogger.fail((0, util_1.stringifyError)(e));
            return;
        }
        finally {
            yield npmPackageManipulator.clean();
        }
        defaultLogger.succeed(locale_1.default.TIP_INSERT_BLOCK_DONE);
    });
}
exports.arcoBlockInsert = arcoBlockInsert;
/**
 * Insert page
 */
function arcoPageInsert(config, contextConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultLogger = new util_1.DefaultLogger(locale_1.default.TIP_INSERT_PAGE_ING);
        const logger = contextConfig.silent ? () => { } : (_msg) => defaultLogger.log(_msg);
        const npmPackageManipulator = new downloader_1.NpmPackageManipulator({
            root: contextConfig.rootPath,
            log: logger,
        });
        try {
            yield executePageWriting(config, npmPackageManipulator, contextConfig, defaultLogger);
        }
        catch (e) {
            defaultLogger.fail((0, util_1.stringifyError)(e));
            return;
        }
        defaultLogger.succeed(locale_1.default.TIP_INSERT_PAGE_DONE);
    });
}
exports.arcoPageInsert = arcoPageInsert;
function executePageWriting(config, packageManipulator, { rootPath, silent }, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        const { routeConfig, packageName } = config;
        // PageName represents the folder name of the current newly created page in the Arco pro project
        // It is also equivalent to the folder name of this newly created page
        // Currently this value is directly derived from 'componentPath'
        const pageName = routeConfig.componentPath;
        const logProgress = silent ? () => { } : (_msg) => logger.log(_msg);
        yield packageManipulator.downloadAndUnzipNpmPackage(packageName);
        const codeDownloadPath = packageManipulator.getPackageDownloadPath(packageName);
        logProgress(locale_1.default.TIP_COPY_SOURCE_ING);
        // Path of target file
        const pagePath = yield handleArcoProFsWrite({
            packageName,
            pageName,
            cwd: rootPath,
            codeDownloadPath,
        });
        logProgress(locale_1.default.TIP_COPY_SOURCE_DONE);
        logProgress(locale_1.default.TIP_HANDLE_MOCK_FILE_ING);
        yield handleCodeInjection(pagePath, rootPath, pageName, config);
        // Installing dependencies.
        const depsStr = packageManipulator.getPackageDependenciesPackString(packageName, rootPath);
        if (depsStr.trim() !== '') {
            logProgress(`${locale_1.default.TIP_INSTALL_DEP_ING}${depsStr}`);
            const exitCode = yield (0, util_1.installDependency)(depsStr, rootPath, logProgress);
            if (exitCode !== 0) {
                throw new Error(`Failed to install npm dependency, please check yarn or npm environment.`);
            }
            else {
                logProgress(locale_1.default.TIP_INSTALL_DEP_DONE);
            }
        }
        logProgress(locale_1.default.TIP_REMOVE_TEMP_FILE_ING);
        yield packageManipulator.clean();
    });
}
exports.executePageWriting = executePageWriting;
function handleCodeInjection(pagePath, rootPath, pageName, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const routeFilePath = path_1.default.join(rootPath, 'src/routes.tsx');
        const routeCode = fs_1.default.readFileSync(routeFilePath).toString();
        const changedRouteCode = (0, babel_1.handleArcoProRoute)({
            routeCode,
            routeObj: config.routeConfig,
            routeParentKey: config.parentKey,
        });
        const formatAndWriteCode = (code, filePath) => __awaiter(this, void 0, void 0, function* () {
            const formattedRouteCode = yield (0, util_1.formatCodeWithPrettierAndEslint)(code, filePath);
            fs_1.default.writeFileSync(filePath, formattedRouteCode);
        });
        yield formatAndWriteCode(changedRouteCode, routeFilePath);
        const localePath = path_1.default.join(pagePath, 'locale');
        if (fs_1.default.existsSync(localePath)) {
            yield Promise.all(fs_1.default.readdirSync(localePath).map((file) => __awaiter(this, void 0, void 0, function* () {
                const extName = path_1.default.extname(file);
                const u18nType = path_1.default.basename(file, extName);
                const localeFilePath = path_1.default.join(rootPath, `src/locale/${file}`);
                const code = fs_1.default.readFileSync(localeFilePath).toString();
                const changedI18nCode = (0, babel_1.handleArcoProI18n)({
                    pageName,
                    localCode: code,
                    localFileName: u18nType,
                });
                yield formatAndWriteCode(changedI18nCode, localeFilePath);
            })));
        }
        if (fs_1.default.existsSync(path_1.default.join(pagePath, 'redux'))) {
            const reduxFilePath = path_1.default.join(rootPath, `src/redux/index.ts`);
            const reduxCode = fs_1.default.readFileSync(reduxFilePath).toString();
            const changedReduxCode = (0, babel_1.handleArcoProRedux)({
                code: reduxCode,
                pageName,
            });
            yield formatAndWriteCode(changedReduxCode, reduxFilePath);
        }
        if (fs_1.default.existsSync(path_1.default.join(pagePath, 'mock.ts'))) {
            const mockFilePath = path_1.default.join(rootPath, `src/mock/index.ts`);
            const mockCode = fs_1.default.readFileSync(mockFilePath).toString();
            const changedMockCode = (0, babel_1.handleArcoProMock)({
                code: mockCode,
                pageName,
            });
            yield formatAndWriteCode(changedMockCode, mockFilePath);
        }
    });
}
