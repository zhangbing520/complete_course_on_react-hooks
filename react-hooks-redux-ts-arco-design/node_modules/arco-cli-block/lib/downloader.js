"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmPackageManipulator = void 0;
const path_1 = __importDefault(require("path"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const compressing_1 = __importDefault(require("compressing"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const arco_cli_dev_utils_1 = require("arco-cli-dev-utils");
const util_1 = require("./util");
const locale_1 = __importDefault(require("./locale"));
const DEFAULT_CACHE_DIRECTORY_NAME = 'download';
const PACKAGE_JSON_RELATIVE_PATH = './package.json';
/**
 * Store the information of a downloaded package including "path", "packageJson" and etc.
 */
class PackageInfoMap {
    constructor() {
        this._map = new Map();
    }
    set(packageName, entryPath) {
        const packageJson = fs_extra_1.default.readJsonSync(path_1.default.join(entryPath, PACKAGE_JSON_RELATIVE_PATH));
        this._map.set(packageName, { path: entryPath, packageJson });
    }
    get(packageName) {
        return this._map.get(packageName);
    }
}
/**
 * Manipulate npm package download and dependencies installation in main project.
 *
 * @example
 * const npm = new NpmPackageManipulator(...);
 * await npm.downloadAndUnzipNpmPackage('react');
 */
class NpmPackageManipulator {
    constructor(ctx) {
        this._packageMap = new PackageInfoMap();
        this._ctx = ctx;
        this._root = ctx.root || process.cwd();
        const tempDirectoryName = ctx.tempDirectoryName || DEFAULT_CACHE_DIRECTORY_NAME;
        this._tempDirectoryPath = path_1.default.join(this._root, `.${tempDirectoryName}`);
    }
    /**
     * Download target npm package.
     */
    downloadAndUnzipNpmPackage(packageName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { scope, name } = (0, util_1.getPackageScopeAndName)(packageName);
            const { npmTarSrc } = yield (0, util_1.getNpmTarSrc)(packageName);
            mkdirp_1.default.sync(path_1.default.join(this._tempDirectoryPath, scope));
            const zipFileDownloadPath = path_1.default.join(this._tempDirectoryPath, `${name}.tgz`);
            this._ctx.log(locale_1.default.TIP_DOWNLOAD_ING);
            yield (0, util_1.wgetAsync)(npmTarSrc, zipFileDownloadPath);
            this._ctx.log(locale_1.default.TIP_DOWNLOAD_DONE);
            // Unzip target npm zip file.
            const unzipTargetPath = path_1.default.join(this._tempDirectoryPath, name);
            this._ctx.log(locale_1.default.TIP_UNZIP_ING);
            yield compressing_1.default.tgz.uncompress(zipFileDownloadPath, unzipTargetPath);
            this._ctx.log(locale_1.default.TIP_UNZIP_DONE);
            this._packageMap.set(packageName, path_1.default.join(unzipTargetPath, 'package'));
            return unzipTargetPath;
        });
    }
    getPackageDownloadPath(packageName) {
        return this.getPackageInfo(packageName).path;
    }
    /**
     * The function will look up from "comparisonTargetFilePath" to find a package.json and use its dependencies
     * to generate diff deps.
     */
    getPackageDependenciesPackString(packageName, comparisonTargetFilePath) {
        const projectDependencies = (0, util_1.getExistingDependencies)(comparisonTargetFilePath);
        const packageJson = this.getPackageInfo(packageName).packageJson;
        const dependencies = packageJson.dependencies;
        let dependenciesStr = '';
        if (dependencies) {
            const diffDeps = (0, util_1.getNewDependencies)(projectDependencies, dependencies) || [];
            dependenciesStr = (0, util_1.getDependenceNameAndVersion)(packageJson.dependencies || {}, diffDeps);
        }
        return dependenciesStr;
    }
    getPackageInfo(packageName) {
        const info = this._packageMap.get(packageName);
        if (!info) {
            throw new Error('Trying to get a undownloaded package: ' +
                `"${packageName}"` +
                "\nPlease invoke 'downloadAndUnzipNpmPackage()' first.");
        }
        return info;
    }
    clean() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, arco_cli_dev_utils_1.execQuick)(`rm -rf ${this._tempDirectoryPath}`);
            this.cleanMap();
        });
    }
    cleanMap() {
        this._packageMap = new PackageInfoMap();
    }
}
exports.NpmPackageManipulator = NpmPackageManipulator;
